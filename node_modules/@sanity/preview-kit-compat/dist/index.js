import { createListenLogic, createRequestMachine, DOMAIN, MSG_HANDSHAKE_SYN, MSG_HANDSHAKE_SYN_ACK, MSG_HANDSHAKE_ACK, MSG_RESPONSE, MSG_HEARTBEAT, MSG_DISCONNECT, createNode, createNodeMachine } from "@sanity/comlink";
import { useState, useEffect, useMemo, useCallback, useSyncExternalStore } from "react";
const channelsToComlinkMap = {
  "handshake/syn": MSG_HANDSHAKE_SYN,
  "handshake/syn-ack": MSG_HANDSHAKE_SYN_ACK,
  "handshake/ack": MSG_HANDSHAKE_ACK,
  "channel/response": MSG_RESPONSE,
  "channel/heartbeat": MSG_HEARTBEAT,
  "channel/disconnect": MSG_DISCONNECT,
  "overlay/focus": "visual-editing/focus",
  "overlay/navigate": "visual-editing/navigate",
  "overlay/toggle": "visual-editing/toggle",
  "presentation/toggleOverlay": "presentation/toggle-overlay"
}, comlinkToChannelsMap = {
  [MSG_HANDSHAKE_SYN]: "handshake/syn",
  [MSG_HANDSHAKE_SYN_ACK]: "handshake/syn-ack",
  [MSG_HANDSHAKE_ACK]: "handshake/ack",
  [MSG_RESPONSE]: "channel/response",
  [MSG_HEARTBEAT]: "channel/heartbeat",
  [MSG_DISCONNECT]: "channel/disconnect",
  "visual-editing/focus": "overlay/focus",
  "visual-editing/navigate": "overlay/navigate",
  "visual-editing/toggle": "overlay/toggle",
  "presentation/toggle-overlay": "presentation/toggleOverlay"
}, convertToComlinkEvent = (event) => {
  const { data } = event;
  return data && typeof data == "object" && "domain" in data && "type" in data && "from" in data && "to" in data && (data.domain === "sanity/channels" && (data.domain = DOMAIN), data.to === "overlays" && (data.to = "visual-editing"), data.from === "overlays" && (data.from = "visual-editing"), data.channelId = data.connectionId, delete data.connectionId, data.type = channelsToComlinkMap[data.type] ?? data.type), event;
}, convertToChannelsMessage = (comlinkMessage) => {
  const { channelId, ...rest } = comlinkMessage, message = { ...rest, connectionId: channelId };
  return message.domain === DOMAIN && (message.domain = "sanity/channels"), message.to === "visual-editing" && (message.to = "overlays"), message.from === "visual-editing" && (message.from = "overlays"), message.type = comlinkToChannelsMap[message.type] ?? message.type, message.type === "channel/response" && message.responseTo && !message.data && (message.data = { responseTo: message.responseTo }), (message.type === "handshake/syn" || message.type === "handshake/syn-ack" || message.type === "handshake/ack") && (message.data = { id: message.connectionId }), message;
}, sendAsChannelsMessage = ({ context }, params) => {
  const { sources, targetOrigin } = context, message = convertToChannelsMessage(params.message);
  sources.forEach((source) => {
    source.postMessage(message, { targetOrigin });
  });
}, createCompatibilityActors = () => ({
  listen: createListenLogic(convertToComlinkEvent),
  requestMachine: createRequestMachine().provide({
    actions: {
      "send message": sendAsChannelsMessage
    }
  })
});
function useDocumentsInUse(documentsInUse, projectId, dataset) {
  const [comlink, setComlink] = useState(null), [connected, setConnected] = useState(!1);
  useEffect(() => {
    if (window.self === window.top && !window.opener)
      return;
    const comlink2 = createNode(
      {
        name: "preview-kit",
        connectTo: "presentation"
      },
      createNodeMachine().provide({
        actors: createCompatibilityActors()
      })
    );
    comlink2.onStatus((status) => {
      status === "connected" ? setConnected(!0) : status === "disconnected" && setConnected(!1);
    });
    const timeout = setTimeout(() => setComlink(comlink2), 0), stop = comlink2.start();
    return () => {
      stop(), setComlink(null), clearTimeout(timeout);
    };
  }, [dataset, projectId]);
  const changedKeys = JSON.stringify(Array.from(documentsInUse.keys()));
  useEffect(() => {
    changedKeys !== "[]" && comlink && connected && comlink.post("preview-kit/documents", {
      projectId,
      dataset,
      perspective: "previewDrafts",
      documents: Array.from(documentsInUse.values())
    });
  }, [changedKeys, comlink, connected, dataset, documentsInUse, projectId]);
}
function useQueryParams(params) {
  const stringifiedParams = useMemo(() => JSON.stringify(params || {}), [params]);
  return useMemo(() => JSON.parse(stringifiedParams), [stringifiedParams]);
}
function useRevalidate(props) {
  const { refreshInterval } = props, shouldPause = useShouldPause(), [state, setState] = useState("hit"), startRefresh = useCallback(() => (setState("inflight"), () => setState("hit")), []);
  return useEffect(() => {
    if (!refreshInterval || state !== "hit")
      return;
    const timeout = setTimeout(() => setState("stale"), refreshInterval);
    return () => clearTimeout(timeout);
  }, [refreshInterval, state]), useEffect(() => {
    if (state !== "hit")
      return;
    const onFocus = () => setState("stale");
    return window.addEventListener("focus", onFocus), () => window.removeEventListener("focus", onFocus);
  }, [refreshInterval, state]), useEffect(() => {
    shouldPause && state === "hit" && setState("stale"), !shouldPause && state === "stale" && setState("refresh");
  }, [shouldPause, state]), [state, startRefresh];
}
function useShouldPause() {
  const [online, setOnline] = useState(!1);
  useEffect(() => {
    setOnline(navigator.onLine);
    const online2 = () => setOnline(!0), offline = () => setOnline(!1);
    return window.addEventListener("online", online2), window.addEventListener("offline", offline), () => {
      window.removeEventListener("online", online2), window.removeEventListener("offline", offline);
    };
  }, []);
  const visibilityState = useSyncExternalStore(
    onVisibilityChange,
    () => document.visibilityState,
    () => "hidden"
  );
  return !online || visibilityState === "hidden";
}
function onVisibilityChange(onStoreChange) {
  return document.addEventListener("visibilitychange", onStoreChange), () => document.removeEventListener("visibilitychange", onStoreChange);
}
export {
  useDocumentsInUse,
  useQueryParams,
  useRevalidate
};
//# sourceMappingURL=index.js.map
