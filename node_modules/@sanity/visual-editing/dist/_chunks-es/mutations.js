import{c as t}from"react-compiler-runtime";import{createIfNotExists as n,patch as e,at as r,insert as o,truncate as s}from"@sanity/mutate";import{D as i}from"./transformSanityNodeData.js";import{createEmptyActor as u}from"xstate";import{useSyncExternalStore as f}from"react";import a from"get-random-values-esm";const c=/_key\s*==\s*['"](.*)['"]/,p=/^\d*:\d*$/;function d(t){return"number"==typeof t||"string"==typeof t&&/^\[\d+\]$/.test(t)}function y(t){return"string"==typeof t?c.test(t.trim()):"object"==typeof t&&"_key"in t}const h=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,m=/_key\s*==\s*['"](.*)['"]/;function l(t,n,e){const r="string"==typeof n?function(t){if("string"!=typeof t)throw new Error("Path is not a string");const n=t.match(h);if(!n)throw new Error("Invalid path string");return n.map(g)}(n):n;if(!Array.isArray(r))throw new Error("Path must be an array or a string");let o=t;for(let t=0;t<r.length;t++){const n=r[t];if(d(n)){if(!Array.isArray(o))return e;o=o[n]}if(y(n)){if(!Array.isArray(o))return e;o=o.find((t=>t._key===n._key))}if("string"==typeof n&&(o="object"==typeof o&&null!==o?o[n]:void 0),typeof o>"u")return e}return o}function g(t){return d(t)?function(t){return Number(t.replace(/[^\d]/g,""))}(t):y(t)?function(t){return{_key:t.match(m)[1]}}(t):function(t){if("string"==typeof t&&p.test(t))return!0;if(!Array.isArray(t)||2!==t.length)return!1;const[n,e]=t;return!("number"!=typeof n&&""!==n||"number"!=typeof e&&""!==e)}(t)?function(t){const[n,e]=t.split(":").map((t=>""===t?t:Number(t)));return[n,e]}(t):t}function b(t){return t.startsWith(i)}function w(t){return b(t)?t:i+t}function k(t){return b(t)?t.slice(i.length):t}const x=u();let _=x;const S=new Set;function I(t){return t===x}function D(t){_=t;for(const t of S)t()}function E(){return f(O,v,A)}function A(){return x}function v(){return _}function O(t){return S.add(t),()=>S.delete(t)}function j(){let t;return t=!I(E()),t}function $(t,n){let e;return(...r)=>{clearTimeout(e),e=setTimeout((()=>{t.apply(t,r)}),n)}}function N(t,n){const e=window.self!==window.top||window.opener;if(I(n)||!e)throw new Error("The `useDocuments` hook cannot be used in this context");const r=w(t),o=k(t),s=n.getSnapshot().context?.documents,i=s?.[r],u=s?.[o],f=i||u;if(!f)throw new Error(`Document "${t}" not found`);const a=i.getSnapshot().context?.local||u.getSnapshot().context?.local,c=new Promise((t=>{if(a)t(a);else{const n=f.on("ready",(e=>{const{snapshot:r}=e;t(r||null),n.unsubscribe()}))}}));return{draftDoc:i,draftId:r,getSnapshot:()=>c,publishedDoc:u,publishedId:o,get snapshot(){if(!a)throw new Error(`Snapshot for document "${t}" not found`);return a}}}function P(t,n){return()=>{const{draftDoc:e}=N(t,n);e.send({type:"submit"})}}function T(t,n){return e=>{const{snapshot:r}=N(t,n);return e?l(r,e):r}}function K(t,n){const{getSnapshot:e}=N(t,n);return e}function U(t,r){return async(o,s)=>{const i=N(t,r),{draftDoc:u,draftId:f,getSnapshot:a,publishedId:c}=i,{commit:p=!0}=s||{},d=await("function"==typeof o?o({draftId:f,publishedId:c,get snapshot(){return i.snapshot},getSnapshot:a}):o),y=await a();if(!y)throw new Error(`Snapshot for document "${t}" not found`);u.send({type:"mutate",mutations:[n({...y,_id:f}),e(f,d)]}),p&&("object"==typeof p&&"debounce"in p?$((()=>u.send({type:"submit"})),p.debounce)():u.send({type:"submit"}))}}function W(){const n=t(7),e=E();let r;n[0]!==e?(r=t=>({id:t,commit:P(t,e),get:T(t,e),getSnapshot:K(t,e),patch:U(t,e)}),n[0]=e,n[1]=r):r=n[1];const o=r;let s;n[2]!==e?(s=(t,n,r)=>{const{draftDoc:o}=N(t,e),{commit:s}=r||{},i=void 0===s||s;o.send({type:"mutate",mutations:n}),i&&("object"==typeof i&&"debounce"in i?$((()=>o.send({type:"submit"})),i.debounce)():o.send({type:"submit"}))},n[2]=e,n[3]=s):s=n[3];const i=s;let u;return n[4]!==o||n[5]!==i?(u={getDocument:o,mutateDocument:i},n[4]=o,n[5]=i,n[6]=u):u=n[6],u}const q=(()=>{let t;return()=>{if(t)return t;t=[];for(let n=0;n<256;++n)t[n]=(n+256).toString(16).slice(1);return t}})();function z(t){const n=q();return function(t=16){const n=new Uint8Array(t);return a(n),n}(t).reduce(((t,e)=>t+n[e]),"").slice(0,t)}function B(t){const n="string"==typeof t?t:t.path,e=n.lastIndexOf("."),r=n.substring(e+1,n.length);if(!r.indexOf("["))throw new Error("Invalid path: not an array");const o=n.lastIndexOf("["),s=n.substring(0,o);let i,u;if(r.includes("_key")){const t=r.indexOf('"')+1,n=r.indexOf('"',t);i=r.substring(t,n),u=!0}else{const t=r.indexOf("[")+1,n=r.indexOf("]",t);i=r.substring(t,n),u=!1}if(!s||!i)throw new Error("Invalid path");return{path:s,key:i,hasExplicitKey:u}}function C(t,n,e="after"){const{path:s,key:i}=B(t),u={...l(n,t.path),_key:z()};return[r(s,o(u,e,{_key:i}))]}function F(t,n){const{path:e,key:o}=B(t),i=l(n,e).findIndex((t=>t._key===o));return[r(e,s(i,i+1))]}function G(t,n,e){const{path:s,key:i}=B(t),u=z();return[r(s,o([{_type:n,_key:u}],e,{_key:i}))]}async function H(t,n,e){if(!t.type)throw new Error("Node type is missing");const{path:i,key:u}=B(t),f=await n.getSnapshot(),a=l(f,i),c=l(f,t.path),p=a.findIndex((t=>t._key===u));let d=-1,y="before";if("first"===e){if(0===p)return[];d=0,y="before"}else if("last"===e){if(p===a.length-1)return[];d=-1,y="after"}else if("next"===e){if(p===a.length-1)return[];d=p,y="after"}else if("previous"===e){if(0===p)return[];d=p-1,y="before"}return[r(i,s(p,p+1)),r(i,o(c,y,d))]}export{W as a,B as b,G as c,l as d,H as e,F as f,k as g,C as h,I as i,j,w as k,D as s,E as u};//# sourceMappingURL=mutations.js.map
