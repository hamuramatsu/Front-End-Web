{"version":3,"file":"mutations.js","sources":["../../../../node_modules/.pnpm/@sanity+types@3.65.1_debug@4.3.7/node_modules/@sanity/types/lib/index.mjs","../../../../node_modules/.pnpm/@sanity+util@3.65.1_debug@4.3.7/node_modules/@sanity/util/lib/paths.mjs","../../src/util/documents.ts","../../src/ui/optimistic-state/context.ts","../../src/ui/optimistic-state/useOptimisticActor.ts","../../src/ui/optimistic-state/useDocuments.ts","../../src/util/randomKey.ts","../../src/util/mutations.ts"],"sourcesContent":["function isObject(obj) {\n  return typeof obj == \"object\" && obj !== null && !Array.isArray(obj);\n}\nfunction isReference(reference) {\n  return isObject(reference) && typeof reference._ref == \"string\";\n}\nfunction isImage(value) {\n  return isObject(value) && isReference(value.asset) && value.asset._ref.startsWith(\"image-\");\n}\nfunction isCrossDatasetReference(reference) {\n  return isObject(reference) && typeof reference._ref == \"string\" && typeof reference._dataset == \"string\" && typeof reference._projectId == \"string\";\n}\nfunction isSanityDocument(document) {\n  return isObject(document) && typeof document._id == \"string\" && typeof document._type == \"string\";\n}\nfunction isTypedObject(obj) {\n  return isObject(obj) && typeof obj._type == \"string\";\n}\nfunction isKeyedObject(obj) {\n  return isObject(obj) && typeof obj._key == \"string\";\n}\nfunction isValidationErrorMarker(marker) {\n  return marker.level === \"error\";\n}\nfunction isValidationWarningMarker(marker) {\n  return marker.level === \"warning\";\n}\nfunction isValidationInfoMarker(marker) {\n  return marker.level === \"info\";\n}\nfunction isCreateMutation(mutation) {\n  return \"create\" in mutation;\n}\nfunction isCreateIfNotExistsMutation(mutation) {\n  return \"createIfNotExists\" in mutation;\n}\nfunction isCreateOrReplaceMutation(mutation) {\n  return \"createOrReplace\" in mutation;\n}\nfunction isDeleteMutation(mutation) {\n  return \"delete\" in mutation;\n}\nfunction isPatchMutation(mutation) {\n  return \"patch\" in mutation;\n}\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/, reIndexTuple = /^\\d*:\\d*$/;\nfunction isIndexSegment(segment) {\n  return typeof segment == \"number\" || typeof segment == \"string\" && /^\\[\\d+\\]$/.test(segment);\n}\nfunction isKeySegment(segment) {\n  return typeof segment == \"string\" ? reKeySegment.test(segment.trim()) : typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction isIndexTuple(segment) {\n  if (typeof segment == \"string\" && reIndexTuple.test(segment))\n    return !0;\n  if (!Array.isArray(segment) || segment.length !== 2)\n    return !1;\n  const [from, to] = segment;\n  return (typeof from == \"number\" || from === \"\") && (typeof to == \"number\" || to === \"\");\n}\nfunction isRecord$1(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction isPortableTextTextBlock(value) {\n  return isRecord$1(value) && typeof value._type == \"string\" && // block types can be named, so expect anything here.\n  Array.isArray(value.children) && value.children.every((child) => isRecord$1(child)) && (\"markDefs\" in value ? Array.isArray(value.markDefs) && value.markDefs.every((def) => isRecord$1(def)) : !0) && (\"style\" in value ? typeof value.style == \"string\" : !0);\n}\nfunction isPortableTextSpan(value) {\n  return isRecord$1(value) && value._type === \"span\" && typeof value.text == \"string\" && (\"marks\" in value ? Array.isArray(value.marks) && value.marks.every((mark) => typeof mark == \"string\") : !0);\n}\nfunction isPortableTextListBlock(value) {\n  return isPortableTextTextBlock(value) && \"listItem\" in value && typeof value.listItem == \"string\" && \"level\" in value && Number.isInteger(value.level);\n}\nfunction isRecord(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction isDocumentSchemaType(type) {\n  if (!isObjectSchemaType(type))\n    return !1;\n  let current = type;\n  for (; current; ) {\n    if (current.name === \"document\")\n      return !0;\n    current = current.type;\n  }\n  return !1;\n}\nfunction isObjectSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"object\" : !1;\n}\nfunction isArraySchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"array\" : !1;\n}\nfunction isArrayOfBlocksSchemaType(type) {\n  return isArraySchemaType(type) && type.of.some((memberType) => isBlockSchemaType(memberType));\n}\nfunction isArrayOfObjectsSchemaType(type) {\n  return isArraySchemaType(type) && type.of.every((memberType) => isObjectSchemaType(memberType));\n}\nfunction isArrayOfPrimitivesSchemaType(type) {\n  return isArraySchemaType(type) && type.of.every((memberType) => isPrimitiveSchemaType(memberType));\n}\nfunction isBooleanSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"boolean\" : !1;\n}\nfunction isStringSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"string\" : !1;\n}\nfunction isNumberSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"number\" : !1;\n}\nfunction isPrimitiveSchemaType(type) {\n  return isBooleanSchemaType(type) || isStringSchemaType(type) || isNumberSchemaType(type);\n}\nfunction isReferenceSchemaType(type) {\n  return isRecord(type) && (type.name === \"reference\" || isReferenceSchemaType(type.type));\n}\nfunction isImageSchemaType(type) {\n  return isRecord(type) && (type.name === \"image\" || isImageSchemaType(type.type));\n}\nfunction isFileSchemaType(type) {\n  return isRecord(type) && (type.name === \"file\" || isFileSchemaType(type.type));\n}\nfunction isDeprecatedSchemaType(type) {\n  return isRecord(type) ? typeof type.deprecated < \"u\" : !1;\n}\nfunction isDeprecationConfiguration(type) {\n  return isRecord(type) ? typeof type.deprecated < \"u\" : !1;\n}\nfunction isCrossDatasetReferenceSchemaType(type) {\n  return isRecord(type) && (type.name === \"crossDatasetReference\" || isCrossDatasetReferenceSchemaType(type.type));\n}\nfunction isTitledListValue(item) {\n  return typeof item == \"object\" && item !== null && \"title\" in item && \"value\" in item;\n}\nfunction isSpanSchemaType(type) {\n  return isRecord(type) ? Array.isArray(type.annotations) && Array.isArray(type.decorators) : !1;\n}\nfunction isBlockSchemaType(type) {\n  if (!isRecord(type) || !Array.isArray(type.fields)) return !1;\n  const maybeSpanChildren = type.fields.find(isBlockChildrenObjectField), maybeStyle = type.fields.find(isBlockStyleObjectField), maybeList = type.fields.find(isBlockListObjectField);\n  return isBlockChildrenObjectField(maybeSpanChildren) && isBlockStyleObjectField(maybeStyle) && isBlockListObjectField(maybeList);\n}\nfunction isBlockStyleObjectField(field) {\n  return !isRecord(field) || field.name !== \"style\" ? !1 : isRecord(field.type) && field.type.jsonType === \"string\";\n}\nfunction isBlockListObjectField(field) {\n  return !isRecord(field) || field.name !== \"listItem\" ? !1 : isRecord(field.type) && field.type.jsonType === \"string\";\n}\nfunction isBlockChildrenObjectField(field) {\n  return !isRecord(field) || field.name !== \"children\" || !isArraySchemaType(field.type) ? !1 : field.type.of.some(isSpanSchemaType);\n}\nfunction defineType(schemaDefinition, defineOptions) {\n  return schemaDefinition;\n}\nfunction defineField(schemaField, defineOptions) {\n  return schemaField;\n}\nfunction defineArrayMember(arrayOfSchema, defineOptions) {\n  return arrayOfSchema;\n}\nfunction typed(input) {\n  return input;\n}\nconst searchStrategies = [\"groqLegacy\", \"textSearch\"];\nfunction isSearchStrategy(maybeSearchStrategy) {\n  return searchStrategies.includes(maybeSearchStrategy);\n}\nfunction isSlug(thing) {\n  return isObject(thing) && typeof thing.current == \"string\";\n}\nfunction isCreateSquashedMutation(mutation) {\n  return \"createSquashed\" in mutation;\n}\nfunction isValidationError(node) {\n  return node.level === \"error\";\n}\nfunction isValidationWarning(node) {\n  return node.level === \"warning\";\n}\nfunction isValidationInfo(node) {\n  return node.level === \"info\";\n}\nexport {\n  defineArrayMember,\n  defineField,\n  defineType,\n  isArrayOfBlocksSchemaType,\n  isArrayOfObjectsSchemaType,\n  isArrayOfPrimitivesSchemaType,\n  isArraySchemaType,\n  isBlockChildrenObjectField,\n  isBlockListObjectField,\n  isBlockSchemaType,\n  isBlockStyleObjectField,\n  isBooleanSchemaType,\n  isCreateIfNotExistsMutation,\n  isCreateMutation,\n  isCreateOrReplaceMutation,\n  isCreateSquashedMutation,\n  isCrossDatasetReference,\n  isCrossDatasetReferenceSchemaType,\n  isDeleteMutation,\n  isDeprecatedSchemaType,\n  isDeprecationConfiguration,\n  isDocumentSchemaType,\n  isFileSchemaType,\n  isImage,\n  isImageSchemaType,\n  isIndexSegment,\n  isIndexTuple,\n  isKeySegment,\n  isKeyedObject,\n  isNumberSchemaType,\n  isObjectSchemaType,\n  isPatchMutation,\n  isPortableTextListBlock,\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  isPrimitiveSchemaType,\n  isReference,\n  isReferenceSchemaType,\n  isSanityDocument,\n  isSearchStrategy,\n  isSlug,\n  isSpanSchemaType,\n  isStringSchemaType,\n  isTitledListValue,\n  isTypedObject,\n  isValidationError,\n  isValidationErrorMarker,\n  isValidationInfo,\n  isValidationInfoMarker,\n  isValidationWarning,\n  isValidationWarningMarker,\n  searchStrategies,\n  typed\n};\n//# sourceMappingURL=index.mjs.map\n","import { isIndexSegment, isKeySegment, isIndexTuple } from \"@sanity/types\";\nconst rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g, reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/, EMPTY_PATH = [], FOCUS_TERMINATOR = \"$\", GROQ_DATA_TYPE_VALUES = [\"true\", \"false\", \"null\"];\nfunction get(obj, path, defaultVal) {\n  const select = typeof path == \"string\" ? fromString(path) : path;\n  if (!Array.isArray(select))\n    throw new Error(\"Path must be an array or a string\");\n  let acc = obj;\n  for (let i = 0; i < select.length; i++) {\n    const segment = select[i];\n    if (isIndexSegment(segment)) {\n      if (!Array.isArray(acc))\n        return defaultVal;\n      acc = acc[segment];\n    }\n    if (isKeySegment(segment)) {\n      if (!Array.isArray(acc))\n        return defaultVal;\n      acc = acc.find((item) => item._key === segment._key);\n    }\n    if (typeof segment == \"string\" && (acc = typeof acc == \"object\" && acc !== null ? acc[segment] : void 0), typeof acc > \"u\")\n      return defaultVal;\n  }\n  return acc;\n}\nconst pathsMemo = /* @__PURE__ */ new Map();\nfunction pathFor(path) {\n  if (path.length === 0)\n    return EMPTY_PATH;\n  const asString = toString(path);\n  return pathsMemo.has(asString) ? pathsMemo.get(asString) : (pathsMemo.set(asString, path), Object.freeze(path), path);\n}\nfunction isEqual(path, otherPath) {\n  return path.length === otherPath.length && path.every((segment, i) => isSegmentEqual(segment, otherPath[i]));\n}\nfunction numEqualSegments(path, otherPath) {\n  const length = Math.min(path.length, otherPath.length);\n  for (let i = 0; i < length; i++)\n    if (!isSegmentEqual(path[i], otherPath[i]))\n      return i;\n  return length;\n}\nfunction isSegmentEqual(segmentA, segmentB) {\n  return isKeySegment(segmentA) && isKeySegment(segmentB) ? segmentA._key === segmentB._key : isIndexSegment(segmentA) ? Number(segmentA) === Number(segmentB) : isIndexTuple(segmentA) && isIndexTuple(segmentB) ? segmentA[0] === segmentB[0] && segmentA[1] === segmentB[1] : segmentA === segmentB;\n}\nfunction hasFocus(focusPath, path) {\n  const withoutTerminator = focusPath[focusPath.length - 1] === FOCUS_TERMINATOR ? focusPath.slice(0, -1) : focusPath;\n  return isEqual(withoutTerminator, path);\n}\nfunction hasItemFocus(focusPath, item) {\n  return focusPath.length === 1 && isSegmentEqual(focusPath[0], item);\n}\nfunction isExpanded(segment, focusPath) {\n  const [head, ...tail] = focusPath;\n  return tail.length > 0 && isSegmentEqual(segment, head);\n}\nfunction startsWith(prefix, path) {\n  return prefix.every((segment, i) => isSegmentEqual(segment, path[i]));\n}\nfunction trimLeft(prefix, path) {\n  if (prefix.length === 0 || path.length === 0)\n    return path;\n  const [prefixHead, ...prefixTail] = prefix, [pathHead, ...pathTail] = path;\n  return isSegmentEqual(prefixHead, pathHead) ? pathFor(trimLeft(prefixTail, pathTail)) : path;\n}\nfunction trimRight(suffix, path) {\n  const sufLen = suffix.length, pathLen = path.length;\n  if (sufLen === 0 || pathLen === 0)\n    return path;\n  let i = 0;\n  for (; i < sufLen && i < pathLen && isSegmentEqual(path[pathLen - i - 1], suffix[sufLen - i - 1]); )\n    i++;\n  return pathFor(path.slice(0, pathLen - i));\n}\nfunction trimChildPath(path, childPath) {\n  return startsWith(path, childPath) ? trimLeft(path, childPath) : EMPTY_PATH;\n}\nfunction toString(path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return path.reduce((target, segment, i) => {\n    const isHead = i === 0;\n    if (typeof segment == \"number\")\n      return `${target}[${segment}]`;\n    if (typeof segment == \"string\")\n      return isHead ? segment : GROQ_DATA_TYPE_VALUES.includes(segment) ? `${target}[\"${segment}\"]` : `${target}.${segment}`;\n    if (isKeySegment(segment) && segment._key)\n      return `${target}[_key==\"${segment._key}\"]`;\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return `${target}[${from}:${to}]`;\n    }\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``);\n  }, \"\");\n}\nfunction _resolveKeyedPath(value, path) {\n  if (path.length === 0)\n    return path;\n  const [next, ...rest] = path;\n  if (typeof next == \"number\") {\n    if (!Array.isArray(value) || !(next in value))\n      return [];\n    const item = value[next];\n    return [typeof item?._key == \"string\" ? { _key: item._key } : next, ..._resolveKeyedPath(item, rest)];\n  }\n  const nextVal = get(value, [next]);\n  return [next, ..._resolveKeyedPath(nextVal, rest)];\n}\nfunction resolveKeyedPath(value, path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return pathFor(_resolveKeyedPath(value, path));\n}\nfunction fromString(path) {\n  if (typeof path != \"string\")\n    throw new Error(\"Path is not a string\");\n  const segments = path.match(rePropName);\n  if (!segments)\n    throw new Error(\"Invalid path string\");\n  return segments.map(normalizePathSegment);\n}\nfunction normalizePathSegment(segment) {\n  return isIndexSegment(segment) ? normalizeIndexSegment(segment) : isKeySegment(segment) ? normalizeKeySegment(segment) : isIndexTuple(segment) ? normalizeIndexTupleSegment(segment) : segment;\n}\nfunction normalizeIndexSegment(segment) {\n  return Number(segment.replace(/[^\\d]/g, \"\"));\n}\nfunction normalizeKeySegment(segment) {\n  return { _key: segment.match(reKeySegment)[1] };\n}\nfunction normalizeIndexTupleSegment(segment) {\n  const [from, to] = segment.split(\":\").map((seg) => seg === \"\" ? seg : Number(seg));\n  return [from, to];\n}\nexport {\n  FOCUS_TERMINATOR,\n  _resolveKeyedPath,\n  fromString,\n  get,\n  hasFocus,\n  hasItemFocus,\n  isEqual,\n  isExpanded,\n  isSegmentEqual,\n  numEqualSegments,\n  pathFor,\n  resolveKeyedPath,\n  startsWith,\n  toString,\n  trimChildPath,\n  trimLeft,\n  trimRight\n};\n//# sourceMappingURL=paths.mjs.map\n","import {DRAFTS_PREFIX} from '@repo/visual-editing-helpers/csm'\n\nexport function isDraftId(id: string): boolean {\n  return id.startsWith(DRAFTS_PREFIX)\n}\n\nexport function getDraftId(id: string): string {\n  return isDraftId(id) ? id : DRAFTS_PREFIX + id\n}\n\nexport function getPublishedId(id: string): string {\n  return isDraftId(id) ? id.slice(DRAFTS_PREFIX.length) : id\n}\n","import {createEmptyActor, type ActorRefFrom} from 'xstate'\nimport {createDatasetMutator} from '../comlink'\n\nexport type MutatorActor = ActorRefFrom<ReturnType<typeof createDatasetMutator>>\nexport type EmptyActor = typeof emptyActor\n\nexport const emptyActor = createEmptyActor()\n\nexport let actor: MutatorActor | EmptyActor = emptyActor\n\nexport const listeners = new Set<() => void>()\n\nexport function isEmptyActor(actor: MutatorActor | EmptyActor): actor is EmptyActor {\n  return actor === emptyActor\n}\n\nexport function setActor(nextActor: MutatorActor): void {\n  actor = nextActor\n  for (const onActorChange of listeners) {\n    onActorChange()\n  }\n}\n","import {useCallback, useMemo, useSyncExternalStore} from 'react'\nimport {\n  actor,\n  emptyActor,\n  isEmptyActor,\n  listeners,\n  type EmptyActor,\n  type MutatorActor,\n} from './context'\n\nexport function useOptimisticActor(): MutatorActor | EmptyActor {\n  const subscribe = useCallback((listener: () => void) => {\n    listeners.add(listener)\n    return () => listeners.delete(listener)\n  }, [])\n\n  const actorRef = useSyncExternalStore(\n    subscribe,\n    () => actor,\n    () => emptyActor,\n  )\n\n  return actorRef\n}\n\nexport function useOptimisticActorReady(): boolean {\n  const actor = useOptimisticActor()\n  return useMemo(() => !isEmptyActor(actor), [actor])\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {SanityDocument} from '@sanity/client'\nimport {createIfNotExists, patch, type Mutation, type NodePatchList} from '@sanity/mutate'\nimport {get as getAtPath} from '@sanity/util/paths'\nimport {useCallback} from 'react'\nimport {getDraftId, getPublishedId} from '../../util/documents'\nimport type {MutatorActor} from './context'\nimport {isEmptyActor} from './context'\nimport {useOptimisticActor} from './useOptimisticActor'\n\nexport type Path<T, K extends keyof T> = K extends string\n  ? T[K] extends Record<string, any>\n    ? `${K}.${Path<T[K], keyof T[K]>}` | K\n    : K\n  : never\n\nexport type PathValue<T, P extends string> = P extends `${infer K}.${infer Rest}`\n  ? K extends keyof T\n    ? PathValue<T[K], Rest>\n    : never\n  : P extends keyof T\n    ? T[P]\n    : never\n\nexport type DocumentsMutate = (\n  documentId: string,\n  mutations: Mutation[],\n  options?: {commit?: boolean | {debounce: number}},\n) => void\n\nexport type DocumentsGet = <T extends Record<string, any>>(\n  documentId: string,\n) => OptimisticDocument<T>\n\nexport type OptimisticDocumentPatches<T extends Record<string, any> = Record<string, any>> =\n  | ((context: {\n      draftId: string\n      publishedId: string\n      /**\n       * @deprecated - use `getSnapshot` instead\n       */\n      snapshot: SanityDocument<T> | undefined\n      getSnapshot: () => Promise<SanityDocument<T> | null>\n    }) => Promise<NodePatchList> | NodePatchList)\n  | NodePatchList\n\nexport type OptimisticDocument<T extends Record<string, any> = Record<string, any>> = {\n  /**\n   * The document ID\n   */\n  id: string\n  /**\n   * Commits any locally applied mutations to the remote document\n   */\n  commit: () => void\n  /**\n   * @deprecated - use `getSnapshot` instead\n   */\n  get: {\n    (): SanityDocument<T> | undefined\n    <P extends Path<T, keyof T>>(path: P): PathValue<T, P> | undefined\n  }\n  /**\n   * Returns a promise that resolves to the current document snapshot\n   */\n  getSnapshot: () => Promise<SanityDocument<T> | null>\n  /**\n   * Applies the given patches to the document\n   */\n  patch: (\n    patches: OptimisticDocumentPatches<T>,\n    options?: {commit?: boolean | {debounce: number}},\n  ) => void\n}\n\nfunction debounce<F extends (...args: Parameters<F>) => ReturnType<F>>(fn: F, timeout: number): F {\n  let timer: ReturnType<typeof setTimeout>\n  return ((...args: Parameters<F>) => {\n    clearTimeout(timer)\n    timer = setTimeout(() => {\n      fn.apply(fn, args)\n    }, timeout)\n  }) as F\n}\n\nfunction getDocumentsAndSnapshot<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  const inFrame = window.self !== window.top || window.opener\n\n  if (isEmptyActor(actor) || !inFrame) {\n    throw new Error('The `useDocuments` hook cannot be used in this context')\n  }\n\n  const draftId = getDraftId(id)\n  const publishedId = getPublishedId(id)\n  const documents = actor.getSnapshot().context?.documents\n\n  const draftDoc = documents?.[draftId]\n  const publishedDoc = documents?.[publishedId]\n  const doc = draftDoc || publishedDoc\n\n  if (!doc) {\n    throw new Error(`Document \"${id}\" not found`)\n  }\n\n  // Helper to get the snapshot from the draft document if it exists, otherwise\n  // fall back to the published document\n  const getDocumentSnapshot = () =>\n    (draftDoc.getSnapshot().context?.local || publishedDoc.getSnapshot().context?.local) as\n      | SanityDocument<T>\n      | null\n      | undefined\n\n  const snapshot = getDocumentSnapshot()\n  const snapshotPromise = new Promise<SanityDocument<T> | null>((resolve) => {\n    if (snapshot) {\n      resolve(snapshot)\n    } else {\n      const subscriber = doc.on('ready', (event) => {\n        // Assert type here as the original document mutator machine doesn't\n        // emit a 'ready' event. We provide a custom action to emit it in this\n        // package's internal `createDatasetMutator` function. <3 xstate.\n        const {snapshot} = event as unknown as {snapshot: SanityDocument<T> | null | undefined}\n        resolve(snapshot || null)\n        subscriber.unsubscribe()\n      })\n    }\n  })\n\n  const getSnapshot = () => snapshotPromise\n\n  return {\n    draftDoc,\n    draftId,\n    getSnapshot,\n    publishedDoc,\n    publishedId,\n    /**\n     * @deprecated - use `getSnapshot` instead\n     */\n    get snapshot() {\n      // Maintain original error throwing behaviour, to avoid breaking changes\n      if (!snapshot) {\n        throw new Error(`Snapshot for document \"${id}\" not found`)\n      }\n      return snapshot\n    },\n  }\n}\n\nfunction createDocumentCommit<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  return (): void => {\n    const {draftDoc} = getDocumentsAndSnapshot<T>(id, actor)\n    draftDoc.send({type: 'submit'})\n  }\n}\n\n/**\n * @deprecated - superseded by `createDocumentGetSnapshot`\n */\nfunction createDocumentGet<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  return <P extends Path<T, keyof T>>(\n    path?: P,\n  ): PathValue<T, P> | SanityDocument<T> | undefined => {\n    const {snapshot} = getDocumentsAndSnapshot<T>(id, actor)\n\n    return path\n      ? (getAtPath(snapshot, path) as PathValue<T, P>)\n      : (snapshot as unknown as SanityDocument<T>)\n  }\n}\n\nfunction createDocumentGetSnapshot<T extends Record<string, any>>(\n  id: string,\n  actor: MutatorActor,\n): () => Promise<SanityDocument<T> | null> {\n  const {getSnapshot} = getDocumentsAndSnapshot<T>(id, actor)\n  return getSnapshot\n}\n\nfunction createDocumentPatch<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  return async (\n    patches: OptimisticDocumentPatches<T>,\n    options?: {commit?: boolean | {debounce: number}},\n  ): Promise<void> => {\n    // Destructure the function result in two steps as we need access to the\n    // `result.snapshot` property in the getter, but don't want to execute the\n    // getter prematurely as it may throw\n    const result = getDocumentsAndSnapshot<T>(id, actor)\n    const {draftDoc, draftId, getSnapshot, publishedId} = result\n\n    const {commit = true} = options || {}\n\n    const context = {\n      draftId,\n      publishedId,\n      /**\n       * @deprecated - use `getSnapshot` instead\n       */\n      get snapshot() {\n        return result.snapshot\n      },\n      getSnapshot,\n    }\n\n    const resolvedPatches = await (typeof patches === 'function' ? patches(context) : patches)\n\n    const _snapshot = await getSnapshot()\n\n    if (!_snapshot) {\n      throw new Error(`Snapshot for document \"${id}\" not found`)\n    }\n\n    draftDoc.send({\n      type: 'mutate',\n      mutations: [\n        // Attempt to create the draft document, it might not exist if the\n        // snapshot was from the published document\n        createIfNotExists({..._snapshot, _id: draftId}),\n        // Patch the draft document with the resolved patches\n        patch(draftId, resolvedPatches),\n      ],\n    })\n\n    if (commit) {\n      if (typeof commit === 'object' && 'debounce' in commit) {\n        const debouncedCommit = debounce(() => draftDoc.send({type: 'submit'}), commit.debounce)\n        debouncedCommit()\n      } else {\n        draftDoc.send({type: 'submit'})\n      }\n    }\n  }\n}\n\nexport function useDocuments(): {\n  getDocument: DocumentsGet\n  mutateDocument: DocumentsMutate\n} {\n  const actor = useOptimisticActor() as MutatorActor\n\n  const getDocument: DocumentsGet = useCallback(\n    <T extends Record<string, any>>(documentId: string) => {\n      return {\n        id: documentId,\n        commit: createDocumentCommit(documentId, actor),\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore - Type instantiation is excessively deep and possibly infinite.\n        get: createDocumentGet(documentId, actor),\n        getSnapshot: createDocumentGetSnapshot<T>(documentId, actor),\n        patch: createDocumentPatch<T>(documentId, actor),\n      }\n    },\n    [actor],\n  )\n\n  const mutateDocument: DocumentsMutate = useCallback(\n    (id, mutations, options) => {\n      const {draftDoc} = getDocumentsAndSnapshot(id, actor)\n      const {commit = true} = options || {}\n\n      draftDoc.send({\n        type: 'mutate',\n        mutations: mutations,\n      })\n\n      if (commit) {\n        if (typeof commit === 'object' && 'debounce' in commit) {\n          const debouncedCommit = debounce(() => draftDoc.send({type: 'submit'}), commit.debounce)\n          debouncedCommit()\n        } else {\n          draftDoc.send({type: 'submit'})\n        }\n      }\n    },\n    [actor],\n  )\n\n  return {getDocument, mutateDocument}\n}\n","import getRandomValues from 'get-random-values-esm'\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  getRandomValues(rnds8)\n  return rnds8\n}\n\nconst getByteHexTable = (() => {\n  let table: string[]\n  return () => {\n    if (table) {\n      return table\n    }\n    table = []\n    for (let i = 0; i < 256; ++i) {\n      table[i] = (i + 0x100).toString(16).slice(1)\n    }\n    return table\n  }\n})()\n\nexport function randomKey(length?: number): string {\n  const table = getByteHexTable()\n  return whatwgRNG(length)\n    .reduce((str, n) => str + table[n], '')\n    .slice(0, length)\n}\n","import type {SanityNode} from '@repo/visual-editing-helpers'\nimport type {SanityDocument} from '@sanity/client'\nimport {at, insert, truncate, type NodePatchList} from '@sanity/mutate'\nimport {get} from '@sanity/util/paths'\nimport type {OptimisticDocument} from '../ui/optimistic-state'\nimport {randomKey} from './randomKey'\n\nexport function getArrayItemKeyAndParentPath(pathOrNode: string | SanityNode): {\n  path: string\n  key: string\n  hasExplicitKey: boolean\n} {\n  const elementPath = typeof pathOrNode === 'string' ? pathOrNode : pathOrNode.path\n\n  const lastDotIndex = elementPath.lastIndexOf('.')\n  const lastPathItem = elementPath.substring(lastDotIndex + 1, elementPath.length)\n\n  if (!lastPathItem.indexOf('[')) throw new Error('Invalid path: not an array')\n\n  const lastArrayIndex = elementPath.lastIndexOf('[')\n  const path = elementPath.substring(0, lastArrayIndex)\n\n  let key\n  let hasExplicitKey\n\n  if (lastPathItem.includes('_key')) {\n    // explicit [_key=\"...\"]\n\n    const startIndex = lastPathItem.indexOf('\"') + 1\n    const endIndex = lastPathItem.indexOf('\"', startIndex)\n\n    key = lastPathItem.substring(startIndex, endIndex)\n\n    hasExplicitKey = true\n  } else {\n    // indexes [int]\n    const startIndex = lastPathItem.indexOf('[') + 1\n    const endIndex = lastPathItem.indexOf(']', startIndex)\n\n    key = lastPathItem.substring(startIndex, endIndex)\n\n    hasExplicitKey = false\n  }\n\n  if (!path || !key) throw new Error('Invalid path')\n\n  return {\n    path,\n    key,\n    hasExplicitKey,\n  }\n}\n\nexport function getArrayDuplicatePatches(\n  node: SanityNode,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  snapshot: SanityDocument<Record<string, any>>,\n  position: 'before' | 'after' = 'after',\n): NodePatchList {\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n\n  const item = get(snapshot, node.path) as object\n  const duplicate = {...item, _key: randomKey()}\n\n  return [at(arrayPath, insert(duplicate, position, {_key: itemKey}))]\n}\n\nexport function getArrayRemovePatches(\n  node: SanityNode,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  snapshot: SanityDocument<Record<string, any>>,\n): NodePatchList {\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n  const array = get(snapshot, arrayPath) as {_key: string}[]\n  const currentIndex = array.findIndex((item) => item._key === itemKey)\n  return [at(arrayPath, truncate(currentIndex, currentIndex + 1))]\n}\n\nexport function getArrayInsertPatches(\n  node: SanityNode,\n  insertType: string,\n  position: 'before' | 'after',\n): NodePatchList {\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n  const insertKey = randomKey()\n  const referenceItem = {_key: itemKey}\n  return [at(arrayPath, insert([{_type: insertType, _key: insertKey}], position, referenceItem))]\n}\n\nexport async function getArrayMovePatches(\n  node: SanityNode,\n  doc: OptimisticDocument,\n  moveTo: 'previous' | 'next' | 'first' | 'last',\n): Promise<NodePatchList> {\n  if (!node.type) throw new Error('Node type is missing')\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n\n  const snapshot = await doc.getSnapshot()\n  const array = get(snapshot, arrayPath) as {_key: string}[]\n  const item = get(snapshot, node.path)\n  const currentIndex = array.findIndex((item) => item._key === itemKey)\n\n  let nextIndex = -1\n  let position: 'before' | 'after' = 'before'\n\n  if (moveTo === 'first') {\n    if (currentIndex === 0) return []\n    nextIndex = 0\n    position = 'before'\n  } else if (moveTo === 'last') {\n    if (currentIndex === array.length - 1) return []\n    nextIndex = -1\n    position = 'after'\n  } else if (moveTo === 'next') {\n    if (currentIndex === array.length - 1) return []\n    nextIndex = currentIndex\n    position = 'after'\n  } else if (moveTo === 'previous') {\n    if (currentIndex === 0) return []\n    nextIndex = currentIndex - 1\n    position = 'before'\n  }\n\n  return [\n    at(arrayPath, truncate(currentIndex, currentIndex + 1)),\n    at(arrayPath, insert(item, position, nextIndex)),\n  ]\n}\n"],"names":["c","createIfNotExists","patch","at","insert","truncate","DRAFTS_PREFIX","createEmptyActor","useSyncExternalStore","getRandomValues","reKeySegment","reIndexTuple","isIndexSegment","segment","test","isKeySegment","trim","rePropName","get","obj","path","defaultVal","select","Error","segments","match","map","normalizePathSegment","fromString","Array","isArray","acc","i","length","find","item","_key","Number","replace","normalizeIndexSegment","normalizeKeySegment","from","to","isIndexTuple","split","seg","normalizeIndexTupleSegment","isDraftId","id","startsWith","getDraftId","getPublishedId","slice","emptyActor","actor","listeners","Set","isEmptyActor","setActor","nextActor","onActorChange","useOptimisticActor","_temp","_temp2","_temp3","listener","add","delete","useOptimisticActorReady","t0","debounce","fn","timeout","timer","args","clearTimeout","setTimeout","apply","getDocumentsAndSnapshot","inFrame","window","self","top","opener","draftId","publishedId","documents","getSnapshot","context","draftDoc","publishedDoc","doc","snapshot","local","snapshotPromise","Promise","resolve","subscriber","on","event","unsubscribe","createDocumentCommit","send","type","createDocumentGet","getAtPath","createDocumentGetSnapshot","createDocumentPatch","async","patches","options","result","commit","resolvedPatches","_snapshot","mutations","_id","useDocuments","$","_c","documentId","getDocument","t1","t2","undefined","mutateDocument","getByteHexTable","table","toString","randomKey","rnds8","Uint8Array","whatwgRNG","reduce","str","n","getArrayItemKeyAndParentPath","pathOrNode","elementPath","lastDotIndex","lastIndexOf","lastPathItem","substring","indexOf","lastArrayIndex","key","hasExplicitKey","includes","startIndex","endIndex","getArrayDuplicatePatches","node","position","arrayPath","itemKey","duplicate","getArrayRemovePatches","currentIndex","findIndex","getArrayInsertPatches","insertType","insertKey","_type","getArrayMovePatches","moveTo","array","nextIndex"],"mappings":"YA6CAA,MAAA,qDAAAC,WAAAC,QAAAC,YAAAC,cAAAC,MAAA,6BAAAC,MAAA,0DAAAC,MAAA,wCAAAC,MAAA,eAAAC,MAAA,wBAAA,MAAMC,EAAe,2BAA4BC,EAAe,YAChE,SAASC,EAAeC,GACf,MAAkB,iBAAXA,GAAyC,iBAAXA,GAAuB,YAAYC,KAAKD,EACtF,CACA,SAASE,EAAaF,GACpB,MAAyB,iBAAXA,EAAsBH,EAAaI,KAAKD,EAAQG,QAA4B,iBAAXH,GAAuB,SAAUA,CAClH,CClDK,MAACI,EAAa,mGAAoGP,EAAe,2BACtI,SAASQ,EAAIC,EAAKC,EAAMC,GACtB,MAAMC,EAAwB,iBAARF,EA6GxB,SAAoBA,GAClB,GAAmB,iBAARA,EACH,MAAA,IAAIG,MAAM,wBACZ,MAAAC,EAAWJ,EAAKK,MAAMR,GAC5B,IAAKO,EACG,MAAA,IAAID,MAAM,uBACX,OAAAC,EAASE,IAAIC,EACtB,CApH2CC,CAAWR,GAAQA,EACxD,IAACS,MAAMC,QAAQR,GACX,MAAA,IAAIC,MAAM,qCAClB,IAAIQ,EAAMZ,EACV,IAAA,IAASa,EAAI,EAAGA,EAAIV,EAAOW,OAAQD,IAAK,CAChC,MAAAnB,EAAUS,EAAOU,GACnB,GAAApB,EAAeC,GAAU,CACvB,IAACgB,MAAMC,QAAQC,GACV,OAAAV,EACTU,EAAMA,EAAIlB,EAChB,CACQ,GAAAE,EAAaF,GAAU,CACrB,IAACgB,MAAMC,QAAQC,GACV,OAAAV,EACTU,EAAMA,EAAIG,MAAMC,GAASA,EAAKC,OAASvB,EAAQuB,MACrD,CACI,GAAsB,iBAAXvB,IAAwBkB,EAAoB,iBAAPA,GAA2B,OAARA,EAAeA,EAAIlB,QAAW,UAAgBkB,EAAM,IAC9G,OAAAV,CACb,CACS,OAAAU,CACT,CAiGA,SAASJ,EAAqBd,GAC5B,OAAOD,EAAeC,GAExB,SAA+BA,GAC7B,OAAOwB,OAAOxB,EAAQyB,QAAQ,SAAU,IAC1C,CAJmCC,CAAsB1B,GAAWE,EAAaF,GAKjF,SAA6BA,GAC3B,MAAO,CAAEuB,KAAMvB,EAAQY,MAAMf,GAAc,GAC7C,CAP4F8B,CAAoB3B,GDrEhH,SAAsBA,GACpB,GAAsB,iBAAXA,GAAuBF,EAAaG,KAAKD,GAC3C,OAAA,EACT,IAAKgB,MAAMC,QAAQjB,IAA+B,IAAnBA,EAAQoB,OAC9B,OAAA,EACH,MAACQ,EAAMC,GAAM7B,EACX,QAAe,iBAAR4B,GAA6B,KAATA,GAA8B,iBAANC,GAAyB,KAAPA,EAC/E,CC8D2HC,CAAa9B,GAQxI,SAAoCA,GAClC,MAAO4B,EAAMC,GAAM7B,EAAQ+B,MAAM,KAAKlB,KAAKmB,GAAgB,KAARA,EAAaA,EAAMR,OAAOQ,KACtE,MAAA,CAACJ,EAAMC,EAChB,CAXmJI,CAA2BjC,GAAWA,CACzL,CCxHO,SAASkC,EAAUC,GACjBA,OAAAA,EAAGC,WAAW3C,EACvB,CAEO,SAAS4C,EAAWF,GACzB,OAAOD,EAAUC,GAAMA,EAAK1C,EAAgB0C,CAC9C,CAEO,SAASG,EAAeH,GAC7B,OAAOD,EAAUC,GAAMA,EAAGI,MAAM9C,EAAc2B,QAAUe,CAC1D,CCNO,MAAMK,EAAa9C,IAEnB,IAAI+C,EAAmCD,EAEjCE,MAAAA,MAAgBC,IAEtB,SAASC,EAAaH,GAC3B,OAAOA,IAAUD,CACnB,CAEO,SAASK,EAASC,GACfA,EAAAA,EACR,IAAA,MAAWC,KAAiBL,EACZK,GAElB,CCXO,SAAAC,IAMYrD,OAAAA,EALjBsD,EAMWC,EAAAC,EAKI,CAZV,SAAAA,IAAAX,OAAAA,CAAA,CAAA,SAAAU,IAAAT,OAAAA,CAAA,CAAA,SAAAQ,EAAAG,GAEHV,OAAAA,EAAAW,IAAcD,GAAS,IACVV,EAAAY,OAAiBF,EAAS,CAYpC,SAAAG,IAC6BC,IAAAA,EACZZ,OAAAA,GAAAA,EADRI,KACPQ,CAA4C,CCgDrD,SAASC,EAA8DC,EAAOC,GACxEC,IAAAA,EACJ,MAAQ,IAAIC,KACVC,aAAaF,GACbA,EAAQG,YAAW,KACdC,EAAAA,MAAMN,EAAIG,EAAI,GAChBF,EAAO,CAEd,CAEA,SAASM,EAAuD9B,EAAYM,GAC1E,MAAMyB,EAAUC,OAAOC,OAASD,OAAOE,KAAOF,OAAOG,OAEjD1B,GAAAA,EAAaH,KAAWyB,EACpB,MAAA,IAAIxD,MAAM,0DAGZ6D,MAAAA,EAAUlC,EAAWF,GACrBqC,EAAclC,EAAeH,GAC7BsC,EAAYhC,EAAMiC,cAAcC,SAASF,UAEzCG,EAAWH,IAAYF,GACvBM,EAAeJ,IAAYD,GAC3BM,EAAMF,GAAYC,EAExB,IAAKC,EACH,MAAM,IAAIpE,MAAM,aAAayB,gBAW/B,MAAM4C,EALHH,EAASF,cAAcC,SAASK,OAASH,EAAaH,cAAcC,SAASK,MAM1EC,EAAkB,IAAIC,SAA+CC,IACrEJ,GAAAA,EACFI,EAAQJ,OACH,CACL,MAAMK,EAAaN,EAAIO,GAAG,SAAoBC,IAItC,MAACP,SAAAA,GAAYO,EACnBH,EAAQJ,GAAY,MACpBK,EAAWG,aAAY,GACxB,KAME,MAAA,CACLX,WACAL,UACAG,YALkBA,IAAMO,EAMxBJ,eACAL,cAIA,YAAIO,GAEF,IAAKA,EACH,MAAM,IAAIrE,MAAM,0BAA0ByB,gBAErC4C,OAAAA,CAAAA,EAGb,CAEA,SAASS,EAAoDrD,EAAYM,GACvE,MAAO,KACC,MAAAmC,SAACA,GAAYX,EAA2B9B,EAAIM,GAClDmC,EAASa,KAAK,CAACC,KAAM,UAAS,CAElC,CAKA,SAASC,EAAiDxD,EAAYM,GACpE,OAEsDlC,IAC9C,MAAAwE,SAACA,GAAYd,EAA2B9B,EAAIM,GAElD,OAAOlC,EACFqF,EAAUb,EAAUxE,GACpBwE,CAAAA,CAET,CAEA,SAASc,EACP1D,EACAM,GAEM,MAAAiC,YAACA,GAAeT,EAA2B9B,EAAIM,GAC9CiC,OAAAA,CACT,CAEA,SAASoB,EAAmD3D,EAAYM,GAC/D,OAAAsD,MACLC,EACAC,KAKA,MAAMC,EAASjC,EAA2B9B,EAAIM,IACxCmC,SAACA,EAAAA,QAAUL,EAAAA,YAASG,EAAAA,YAAaF,GAAe0B,GAEhDC,OAACA,GAAS,GAAQF,GAAW,CAAA,EAc7BG,QAA4C,mBAAZJ,EAAyBA,EAZ/C,CACdzB,UACAC,cAIA,YAAIO,GACF,OAAOmB,EAAOnB,QAChB,EACAL,gBAGgFsB,GAE5EK,QAAkB3B,IAExB,IAAK2B,EACH,MAAM,IAAI3F,MAAM,0BAA0ByB,gBAG5CyC,EAASa,KAAK,CACZC,KAAM,SACNY,UAAW,CAGTlH,EAAkB,IAAIiH,EAAWE,IAAKhC,IAEtClF,EAAMkF,EAAS6B,MAIfD,IACoB,iBAAXA,GAAuB,aAAcA,EACtB1C,GAAS,IAAMmB,EAASa,KAAK,CAACC,KAAM,YAAYS,EAAO1C,SAAvDA,GAGxBmB,EAASa,KAAK,CAACC,KAAM,WAAS,CAItC,CAEO,SAAAc,IAAA,MAAAC,EAAAC,EAAA,GAILjE,EAAcO,IAAoCQ,IAAAA,EAAAiD,OAAAhE,GAGhDe,EAAAmD,IAAA,CAAAxE,GAEQwE,EAAUR,OACNX,EAAqBmB,EAAYlE,GAAMpC,IAG1CsF,EAAkBgB,EAAYlE,GAAMiC,YAC5BmB,EAA6Bc,EAAYlE,GAAMpD,MACrDyG,EAAuBa,EAAYlE,KAE7CgE,KAAAhE,EAAAgE,KAAAjD,GAAAA,EAAAiD,EAAA,GAXH,MAAAG,EAAkCpD,EAajCqD,IAAAA,EAAAJ,OAAAhE,GAGCoE,EAAAA,CAAA1E,EAAAmE,EAAAL,KACE,MAAArB,SAAAA,GAAmBX,EAAwB9B,EAAIM,IAC/C0D,OAAAW,GAAwBb,GAAa,CAAA,EAA9BE,OAAaY,IAAbD,GAAAA,EAEPlC,EAAQa,KAAA,CAAAC,KACA,SAAQY,cAIZH,IACoB,iBAAXA,GAAuB,aAAcA,EACtB1C,GAAemB,IAAAA,EAAQa,KAAA,CAAAC,KAAa,YAAYS,EAAM1C,SAAtDA,GAGxBmB,EAAQa,KAAA,CAAAC,KAAa,WAAS,EAGnCe,KAAAhE,EAAAgE,KAAAI,GAAAA,EAAAJ,EAAA,GAlBH,MAAAO,EAAwCH,EAoBvCC,IAAAA,EAAAL,OAAAA,EAAAG,KAAAA,GAAAH,OAAAO,GAEMF,EAAA,CAAAF,cAAAI,kBAA6BP,KAAAG,EAAAH,KAAAO,EAAAP,KAAAK,GAAAA,EAAAL,EAAA,GAA7BK,CAA6B,CC5QtC,MAAMG,EAAyB,MACzBC,IAAAA,EACJ,MAAO,KACDA,GAAAA,EACKA,OAAAA,EAETA,EAAQ,GACR,IAAA,IAAS/F,EAAI,EAAGA,EAAI,MAAOA,EACnBA,EAAAA,IAAMA,EAAI,KAAOgG,SAAS,IAAI5E,MAAM,GAErC2E,OAAAA,CAAAA,CAER,EAZ4B,GAcxB,SAASE,EAAUhG,GACxB,MAAM8F,EAAQD,IACd,OAtBF,SAAmB7F,EAAS,IACpBiG,MAAAA,EAAQ,IAAIC,WAAWlG,GAC7BxB,OAAAA,EAAgByH,GACTA,CACT,CAkBSE,CAAUnG,GACdoG,QAAO,CAACC,EAAKC,IAAMD,EAAMP,EAAMQ,IAAI,IACnCnF,MAAM,EAAGnB,EACd,CCrBO,SAASuG,EAA6BC,GAK3C,MAAMC,EAAoC,iBAAfD,EAA0BA,EAAaA,EAAWrH,KAEvEuH,EAAeD,EAAYE,YAAY,KACvCC,EAAeH,EAAYI,UAAUH,EAAe,EAAGD,EAAYzG,QAErE,IAAC4G,EAAaE,QAAQ,KAAY,MAAA,IAAIxH,MAAM,8BAE1CyH,MAAAA,EAAiBN,EAAYE,YAAY,KACzCxH,EAAOsH,EAAYI,UAAU,EAAGE,GAEtC,IAAIC,EACAC,EAEAL,GAAAA,EAAaM,SAAS,QAAS,CAG3BC,MAAAA,EAAaP,EAAaE,QAAQ,KAAO,EACzCM,EAAWR,EAAaE,QAAQ,IAAKK,GAE3CH,EAAMJ,EAAaC,UAAUM,EAAYC,GAEzCH,GAAiB,CAAA,KACZ,CAECE,MAAAA,EAAaP,EAAaE,QAAQ,KAAO,EACzCM,EAAWR,EAAaE,QAAQ,IAAKK,GAE3CH,EAAMJ,EAAaC,UAAUM,EAAYC,GAEzCH,GAAiB,CAAA,CAGnB,IAAK9H,IAAS6H,EAAW,MAAA,IAAI1H,MAAM,gBAE5B,MAAA,CACLH,OACA6H,MACAC,iBAEJ,CAEO,SAASI,EACdC,EAEA3D,EACA4D,EAA+B,SAEzB,MAACpI,KAAMqI,EAAWR,IAAKS,GAAWlB,EAA6Be,GAG/DI,EAAY,IADLzI,EAAI0E,EAAU2D,EAAKnI,MACJgB,KAAM6F,KAElC,MAAO,CAAC9H,EAAGsJ,EAAWrJ,EAAOuJ,EAAWH,EAAU,CAACpH,KAAMsH,KAC3D,CAEgBE,SAAAA,EACdL,EAEA3D,GAEM,MAACxE,KAAMqI,EAAWR,IAAKS,GAAWlB,EAA6Be,GAE/DM,EADQ3I,EAAI0E,EAAU6D,GACDK,WAAoB3H,GAAAA,EAAKC,OAASsH,IACtD,MAAA,CAACvJ,EAAGsJ,EAAWpJ,EAASwJ,EAAcA,EAAe,IAC9D,CAEgBE,SAAAA,EACdR,EACAS,EACAR,GAEM,MAACpI,KAAMqI,EAAWR,IAAKS,GAAWlB,EAA6Be,GAC/DU,EAAYhC,IAElB,MAAO,CAAC9H,EAAGsJ,EAAWrJ,EAAO,CAAC,CAAC8J,MAAOF,EAAY5H,KAAM6H,IAAaT,EAD/C,CAACpH,KAAMsH,KAE/B,CAEsBS,eAAAA,EACpBZ,EACA5D,EACAyE,GAEA,IAAKb,EAAKhD,KAAY,MAAA,IAAIhF,MAAM,wBAC1B,MAACH,KAAMqI,EAAWR,IAAKS,GAAWlB,EAA6Be,GAE/D3D,QAAiBD,EAAIJ,cACrB8E,EAAQnJ,EAAI0E,EAAU6D,GACtBtH,EAAOjB,EAAI0E,EAAU2D,EAAKnI,MAC1ByI,EAAeQ,EAAMP,WAAW3H,GAASA,EAAKC,OAASsH,IAEzDY,IAAAA,KACAd,EAA+B,SAEnC,GAAe,UAAXY,EAAoB,CAClBP,GAAiB,IAAjBA,EAAoB,MAAO,GAC/BS,EAAY,EACZd,EAAW,QAAA,MAAA,GACS,SAAXY,EAAmB,CAC5B,GAAIP,IAAiBQ,EAAMpI,OAAS,QAAU,GAC9CqI,KACAd,EAAW,OAAA,MAAA,GACS,SAAXY,EAAmB,CAC5B,GAAIP,IAAiBQ,EAAMpI,OAAS,QAAU,GAC9CqI,EAAYT,EACZL,EAAW,OAAA,MAAA,GACS,aAAXY,EAAuB,CAC5BP,GAAiB,IAAjBA,EAAoB,MAAO,GACnBA,EAAAA,EAAe,EAC3BL,EAAW,QAAA,CAGb,MAAO,CACLrJ,EAAGsJ,EAAWpJ,EAASwJ,EAAcA,EAAe,IACpD1J,EAAGsJ,EAAWrJ,EAAO+B,EAAMqH,EAAUc,IAEzC","x_google_ignoreList":[0,1]}